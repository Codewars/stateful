{"name":"Stateful","tagline":"Very simple Ruby state machine. ","body":"# Stateful\r\n\r\nA simple state machine gem. Works with plain ruby objects and Mongoid. This gem aims\r\nto keep things simple. It supports the following:\r\n\r\n- Simple event model, just use plain ruby methods as your events and use the change_state helper to change the state.\r\n- Supports virtual/grouped states that can be used to break down top level states into more granular sub-states.\r\n- Utilizes ActiveSupport::Callbacks\r\n- Simple hash structure for defining states and their possible transitions. No complicated DSL to learn.\r\n- ActiveSupport is the only dependency.\r\n- Very small code footprint.\r\n- Mongoid support, automatically creates field, validations and scopes for you.\r\n- Supports multiple state fields on the same object\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'stateful'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install stateful\r\n\r\n## Usage\r\n\r\n```ruby\r\nclass Project\r\n    include Stateful\r\n\r\n    attr_reader :published_at\r\n\r\n    stateful default: :new,\r\n             events: [:publish, :unpublish, :approve, :close, :mark_as_duplicate],\r\n             states: {\r\n                active: {\r\n                    new: :published,\r\n                    published: {\r\n                        needs_approval: [:approved, :duplicate, :new],\r\n                        approved: :closed\r\n                    }\r\n                },\r\n                inactive: {\r\n                    closed: nil,\r\n                    duplicate: nil\r\n                }\r\n             }\r\n\r\n    def publish\r\n        # change the state to needs_approval and fire publish events. The block will only be\r\n        # called if the state can successfully be changed.\r\n        change_state(:needs_approval, :publish) do\r\n            @published_at = Time.now\r\n        end\r\n    end\r\n\r\n    # use callbacks if you want\r\n    after_publish do |project|\r\n        NotificationService.notify_project_published(project)\r\n    end\r\n\r\n    # define other event methods ...\r\nend\r\n\r\nproject = Project.new\r\nproject.active? # => true\r\nproject.new? # => true\r\nproject.published? # => false\r\n```\r\n\r\nIf you are using with Mongoid a field called state will automatically be created for you.\r\n\r\n```ruby\r\nclass Project\r\n    include Mongoid::Document # must be included first\r\n    include Stateful\r\n\r\n    field :published_at, type: Time\r\n\r\n    stateful default: :new,\r\n             events: [:publish, :unpublish, :approve, :close, :mark_as_duplicate],\r\n             states: {\r\n                active: {\r\n                    new: :published,\r\n                    published: {\r\n                        needs_approval: [:approved, :duplicate],\r\n                        approved: :closed\r\n                    }\r\n                },\r\n                inactive: {\r\n                    closed: nil,\r\n                    duplicate: nil\r\n                }\r\n             }\r\n\r\n\r\n    # ...\r\nend\r\n\r\n# scopes are automatically created for you\r\nProject.active.count\r\nProject.published.count\r\n```\r\n\r\n### State Event Helpers\r\n\r\nTwo forms of change state methods are provided. There is the `change_state` method that was demonstrated above and then there is the `change_state!` version, which will raise an error instead of returning false if the state cannot be changed. \r\n\r\n`change_state` and `change_state!` are great low level utilities for changing the state of the object. However one issue is that sometimes you wish to provide both a bang and non-bang version of an event method. For example:\r\n\r\n```ruby\r\ndef publish\r\n  change_state(:needs_approval, :publish) do\r\n    @published_at = Time.now\r\n  end\r\nend\r\n\r\ndef publish!\r\n  change_state!(:needs_approval, :publish) do\r\n    @published_at = Time.now\r\n  end\r\nend\r\n```\r\n\r\nClearly this is not very dry. You could dry it up some more by using a callback, such as like this:\r\n\r\n```ruby\r\ndef publish\r\n  change_state(:needs_approval, :publish)\r\nend\r\n\r\ndef publish!\r\n  change_state!(:needs_approval, :publish)\r\nend\r\n\r\nbefore_publish do\r\n  @published_at = Time.now\r\nend\r\n```\r\n\r\nHowever this is not much better. Especially if there is additional logic contained within the publish methods. Because of this there is an additional class helper called `state_event` that you can use to define both `publish` and `publish!` while only having to declare the logic once. \r\n\r\n```ruby\r\nstate_event :publish do\r\n  transition_to_state(:published) do\r\n    @published_at = Time.now\r\n  end\r\nend\r\n```\r\n\r\nSo what is going on here? The `state_event` method is being passed the event name, which causes both the `publish` and `publish!` methods to be created. Additionally there is a new instance method available that is called `transition_to_state(new_state)`. When this method is invoked it will in turn call either `change_state(new_state, :publish)` or `change_state!(new_state, :published)`\r\n\r\n**Note** that `transition_to_state` is only meant to be called while one of the the event methods (in this example either `publish` or `publish!`) are being invoked. Calling this method any other time will raise an error.\r\n\r\n**Also note** that currently `state_event` does not support handling method arguments. This is a planned feature but for now, if you need to support both bang and non-bang versions than you will need to use the lower level `change_state` method. \r\n\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}